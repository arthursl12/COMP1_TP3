

Terminals which are not used:

   SIN
   LOG
   COS
   ORD
   CHR
   ABS
   SQRT
   EXP
   EOF_TOKEN


Conflict in state 86 between rule 26 and token ELSE resolved as shift.

Grammar
rule 1    program -> PROGRAM IDENTIFIER ';' decl_list compound_stmt
rule 2    decl_list -> decl_list ';' decl
rule 3    decl_list -> decl
rule 4    decl -> ident_list ':' type
rule 5    ident_list -> ident_list ',' IDENTIFIER
rule 6    ident_list -> IDENTIFIER
rule 7    type -> INTEGER
rule 8    type -> REAL
rule 9    type -> BOOLEAN
rule 10   type -> CHAR
rule 11   compound_stmt -> BEGIN_STMT stmt_list END
rule 12   stmt_list -> stmt_list ';' stmt
rule 13   stmt_list -> stmt
rule 14   stmt -> label ':' unlabelled_stmt
rule 15   stmt -> unlabelled_stmt
rule 16   label -> IDENTIFIER
rule 17   unlabelled_stmt -> assign_stmt
rule 18   unlabelled_stmt -> if_stmt
rule 19   unlabelled_stmt -> loop_stmt
rule 20   unlabelled_stmt -> read_stmt
rule 21   unlabelled_stmt -> write_stmt
rule 22   unlabelled_stmt -> goto_stmt
rule 23   unlabelled_stmt -> compound_stmt
rule 24   assign_stmt -> IDENTIFIER ASSIGN expr
rule 25   cond -> expr
rule 26   if_stmt -> IF cond THEN stmt
rule 27   if_stmt -> IF cond THEN stmt ELSE stmt
rule 28   loop_stmt -> stmt_prefix DO stmt_list stmt_suffix
rule 29   stmt_prefix -> WHILE cond
rule 30   stmt_prefix ->		/* empty */
rule 31   stmt_suffix -> UNTIL cond
rule 32   stmt_suffix -> END
rule 33   read_stmt -> READ '(' ident_list ')'
rule 34   write_stmt -> WRITE '(' expr_list ')'
rule 35   goto_stmt -> GOTO IDENTIFIER
rule 36   expr_list -> expr
rule 37   expr_list -> expr_list ',' expr
rule 38   expr -> simple_expr
rule 39   expr -> simple_expr RELOP simple_expr
rule 40   simple_expr -> term
rule 41   simple_expr -> simple_expr ADDOP term
rule 42   simple_expr -> simple_expr '-' term
rule 43   term -> factor_a
rule 44   term -> term MULOP factor_a
rule 45   function_ref -> EOLN
rule 46   function_ref -> function_ref_par
rule 47   function_ref_par -> variable '(' expr_list ')'
rule 48   variable -> simple_variable_or_proc
rule 49   variable -> function_ref_par
rule 50   simple_variable_or_proc -> IDENTIFIER_F
rule 51   factor_a -> '-' factor
rule 52   factor_a -> factor
rule 53   factor -> IDENTIFIER
rule 54   factor -> constant
rule 55   factor -> '(' expr ')'
rule 56   factor -> function_ref
rule 57   factor -> NOT factor
rule 58   constant -> INT_CONSTANT
rule 59   constant -> REAL_CONSTANT
rule 60   constant -> CHAR_CONSTANT
rule 61   constant -> BOOL_CONSTANT

Terminals, with rules where they appear

$ (-1)
'(' (40) 33 34 47 55
')' (41) 33 34 47 55
',' (44) 5 37
'-' (45) 42 51
':' (58) 4 14
';' (59) 1 2 12
error (256)
ADDOP (258) 41
RELOP (259) 39
MULOP (260) 44
NOT (261) 57
ASSIGN (262) 24
INT_CONSTANT (263) 58
REAL_CONSTANT (264) 59
BOOL_CONSTANT (265) 61
IDENTIFIER (266) 1 5 6 16 24 35 53
IDENTIFIER_F (267) 50
CHAR_CONSTANT (268) 60
PROGRAM (269) 1
INTEGER (270) 7
REAL (271) 8
BOOLEAN (272) 9
CHAR (273) 10
BEGIN_STMT (274) 11
END (275) 11 32
IF (276) 26 27
THEN (277) 26 27
ELSE (278) 27
DO (279) 28
WHILE (280) 29
UNTIL (281) 31
READ (282) 33
WRITE (283) 34
GOTO (284) 35
SIN (285)
LOG (286)
COS (287)
ORD (288)
CHR (289)
ABS (290)
SQRT (291)
EXP (292)
EOF_TOKEN (293)
EOLN (294) 45

Nonterminals, with rules where they appear

program (46)
    on left: 1
decl_list (47)
    on left: 2 3, on right: 1 2
decl (48)
    on left: 4, on right: 2 3
ident_list (49)
    on left: 5 6, on right: 4 5 33
type (50)
    on left: 7 8 9 10, on right: 4
compound_stmt (51)
    on left: 11, on right: 1 23
stmt_list (52)
    on left: 12 13, on right: 11 12 28
stmt (53)
    on left: 14 15, on right: 12 13 26 27
label (54)
    on left: 16, on right: 14
unlabelled_stmt (55)
    on left: 17 18 19 20 21 22 23, on right: 14 15
assign_stmt (56)
    on left: 24, on right: 17
cond (57)
    on left: 25, on right: 26 27 29 31
if_stmt (58)
    on left: 26 27, on right: 18
loop_stmt (59)
    on left: 28, on right: 19
stmt_prefix (60)
    on left: 29 30, on right: 28
stmt_suffix (61)
    on left: 31 32, on right: 28
read_stmt (62)
    on left: 33, on right: 20
write_stmt (63)
    on left: 34, on right: 21
goto_stmt (64)
    on left: 35, on right: 22
expr_list (65)
    on left: 36 37, on right: 34 37 47
expr (66)
    on left: 38 39, on right: 24 25 36 37 55
simple_expr (67)
    on left: 40 41 42, on right: 38 39 41 42
term (68)
    on left: 43 44, on right: 40 41 42 44
function_ref (69)
    on left: 45 46, on right: 56
function_ref_par (70)
    on left: 47, on right: 46 49
variable (71)
    on left: 48 49, on right: 47
simple_variable_or_proc (72)
    on left: 50, on right: 48
factor_a (73)
    on left: 51 52, on right: 43 44
factor (74)
    on left: 53 54 55 56 57, on right: 51 52 57
constant (75)
    on left: 58 59 60 61, on right: 54


state 0

    PROGRAM	shift, and go to state 1

    program	go to state 103



state 1

    program  ->  PROGRAM . IDENTIFIER ';' decl_list compound_stmt   (rule 1)

    IDENTIFIER	shift, and go to state 2



state 2

    program  ->  PROGRAM IDENTIFIER . ';' decl_list compound_stmt   (rule 1)

    ';' 	shift, and go to state 3



state 3

    program  ->  PROGRAM IDENTIFIER ';' . decl_list compound_stmt   (rule 1)

    IDENTIFIER	shift, and go to state 4

    decl_list	go to state 5
    decl	go to state 6
    ident_list	go to state 7



state 4

    ident_list  ->  IDENTIFIER .   (rule 6)

    $default	reduce using rule 6 (ident_list)



state 5

    program  ->  PROGRAM IDENTIFIER ';' decl_list . compound_stmt   (rule 1)
    decl_list  ->  decl_list . ';' decl   (rule 2)

    BEGIN_STMT	shift, and go to state 8
    ';' 	shift, and go to state 9

    compound_stmt	go to state 10



state 6

    decl_list  ->  decl .   (rule 3)

    $default	reduce using rule 3 (decl_list)



state 7

    decl  ->  ident_list . ':' type   (rule 4)
    ident_list  ->  ident_list . ',' IDENTIFIER   (rule 5)

    ':' 	shift, and go to state 11
    ',' 	shift, and go to state 12



state 8

    compound_stmt  ->  BEGIN_STMT . stmt_list END   (rule 11)

    IDENTIFIER	shift, and go to state 13
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    stmt_list	go to state 20
    stmt	go to state 21
    label	go to state 22
    unlabelled_stmt	go to state 23
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 9

    decl_list  ->  decl_list ';' . decl   (rule 2)

    IDENTIFIER	shift, and go to state 4

    decl	go to state 31
    ident_list	go to state 7



state 10

    program  ->  PROGRAM IDENTIFIER ';' decl_list compound_stmt .   (rule 1)

    $default	reduce using rule 1 (program)



state 11

    decl  ->  ident_list ':' . type   (rule 4)

    INTEGER	shift, and go to state 32
    REAL	shift, and go to state 33
    BOOLEAN	shift, and go to state 34
    CHAR	shift, and go to state 35

    type	go to state 36



state 12

    ident_list  ->  ident_list ',' . IDENTIFIER   (rule 5)

    IDENTIFIER	shift, and go to state 37



state 13

    label  ->  IDENTIFIER .   (rule 16)
    assign_stmt  ->  IDENTIFIER . ASSIGN expr   (rule 24)

    ASSIGN	shift, and go to state 38

    $default	reduce using rule 16 (label)



state 14

    if_stmt  ->  IF . cond THEN stmt   (rule 26)
    if_stmt  ->  IF . cond THEN stmt ELSE stmt   (rule 27)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    cond	go to state 49
    expr	go to state 50
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 15

    stmt_prefix  ->  WHILE . cond   (rule 29)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    cond	go to state 60
    expr	go to state 50
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 16

    read_stmt  ->  READ . '(' ident_list ')'   (rule 33)

    '(' 	shift, and go to state 61



state 17

    write_stmt  ->  WRITE . '(' expr_list ')'   (rule 34)

    '(' 	shift, and go to state 62



state 18

    goto_stmt  ->  GOTO . IDENTIFIER   (rule 35)

    IDENTIFIER	shift, and go to state 63



state 19

    unlabelled_stmt  ->  compound_stmt .   (rule 23)

    $default	reduce using rule 23 (unlabelled_stmt)



state 20

    compound_stmt  ->  BEGIN_STMT stmt_list . END   (rule 11)
    stmt_list  ->  stmt_list . ';' stmt   (rule 12)

    END 	shift, and go to state 64
    ';' 	shift, and go to state 65



state 21

    stmt_list  ->  stmt .   (rule 13)

    $default	reduce using rule 13 (stmt_list)



state 22

    stmt  ->  label . ':' unlabelled_stmt   (rule 14)

    ':' 	shift, and go to state 66



state 23

    stmt  ->  unlabelled_stmt .   (rule 15)

    $default	reduce using rule 15 (stmt)



state 24

    unlabelled_stmt  ->  assign_stmt .   (rule 17)

    $default	reduce using rule 17 (unlabelled_stmt)



state 25

    unlabelled_stmt  ->  if_stmt .   (rule 18)

    $default	reduce using rule 18 (unlabelled_stmt)



state 26

    unlabelled_stmt  ->  loop_stmt .   (rule 19)

    $default	reduce using rule 19 (unlabelled_stmt)



state 27

    loop_stmt  ->  stmt_prefix . DO stmt_list stmt_suffix   (rule 28)

    DO  	shift, and go to state 67



state 28

    unlabelled_stmt  ->  read_stmt .   (rule 20)

    $default	reduce using rule 20 (unlabelled_stmt)



state 29

    unlabelled_stmt  ->  write_stmt .   (rule 21)

    $default	reduce using rule 21 (unlabelled_stmt)



state 30

    unlabelled_stmt  ->  goto_stmt .   (rule 22)

    $default	reduce using rule 22 (unlabelled_stmt)



state 31

    decl_list  ->  decl_list ';' decl .   (rule 2)

    $default	reduce using rule 2 (decl_list)



state 32

    type  ->  INTEGER .   (rule 7)

    $default	reduce using rule 7 (type)



state 33

    type  ->  REAL .   (rule 8)

    $default	reduce using rule 8 (type)



state 34

    type  ->  BOOLEAN .   (rule 9)

    $default	reduce using rule 9 (type)



state 35

    type  ->  CHAR .   (rule 10)

    $default	reduce using rule 10 (type)



state 36

    decl  ->  ident_list ':' type .   (rule 4)

    $default	reduce using rule 4 (decl)



state 37

    ident_list  ->  ident_list ',' IDENTIFIER .   (rule 5)

    $default	reduce using rule 5 (ident_list)



state 38

    assign_stmt  ->  IDENTIFIER ASSIGN . expr   (rule 24)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    expr	go to state 68
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 39

    factor  ->  NOT . factor   (rule 57)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47

    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor	go to state 69
    constant	go to state 59



state 40

    constant  ->  INT_CONSTANT .   (rule 58)

    $default	reduce using rule 58 (constant)



state 41

    constant  ->  REAL_CONSTANT .   (rule 59)

    $default	reduce using rule 59 (constant)



state 42

    constant  ->  BOOL_CONSTANT .   (rule 61)

    $default	reduce using rule 61 (constant)



state 43

    factor  ->  IDENTIFIER .   (rule 53)

    $default	reduce using rule 53 (factor)



state 44

    simple_variable_or_proc  ->  IDENTIFIER_F .   (rule 50)

    $default	reduce using rule 50 (simple_variable_or_proc)



state 45

    constant  ->  CHAR_CONSTANT .   (rule 60)

    $default	reduce using rule 60 (constant)



state 46

    function_ref  ->  EOLN .   (rule 45)

    $default	reduce using rule 45 (function_ref)



state 47

    factor  ->  '(' . expr ')'   (rule 55)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    expr	go to state 70
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 48

    factor_a  ->  '-' . factor   (rule 51)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47

    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor	go to state 71
    constant	go to state 59



state 49

    if_stmt  ->  IF cond . THEN stmt   (rule 26)
    if_stmt  ->  IF cond . THEN stmt ELSE stmt   (rule 27)

    THEN	shift, and go to state 72



state 50

    cond  ->  expr .   (rule 25)

    $default	reduce using rule 25 (cond)



state 51

    expr  ->  simple_expr .   (rule 38)
    expr  ->  simple_expr . RELOP simple_expr   (rule 39)
    simple_expr  ->  simple_expr . ADDOP term   (rule 41)
    simple_expr  ->  simple_expr . '-' term   (rule 42)

    ADDOP	shift, and go to state 73
    RELOP	shift, and go to state 74
    '-' 	shift, and go to state 75

    $default	reduce using rule 38 (expr)



state 52

    simple_expr  ->  term .   (rule 40)
    term  ->  term . MULOP factor_a   (rule 44)

    MULOP	shift, and go to state 76

    $default	reduce using rule 40 (simple_expr)



state 53

    factor  ->  function_ref .   (rule 56)

    $default	reduce using rule 56 (factor)



state 54

    function_ref  ->  function_ref_par .   (rule 46)
    variable  ->  function_ref_par .   (rule 49)

    $default	reduce using rule 46 (function_ref)



state 55

    function_ref_par  ->  variable . '(' expr_list ')'   (rule 47)

    '(' 	shift, and go to state 77



state 56

    variable  ->  simple_variable_or_proc .   (rule 48)

    $default	reduce using rule 48 (variable)



state 57

    term  ->  factor_a .   (rule 43)

    $default	reduce using rule 43 (term)



state 58

    factor_a  ->  factor .   (rule 52)

    $default	reduce using rule 52 (factor_a)



state 59

    factor  ->  constant .   (rule 54)

    $default	reduce using rule 54 (factor)



state 60

    stmt_prefix  ->  WHILE cond .   (rule 29)

    $default	reduce using rule 29 (stmt_prefix)



state 61

    read_stmt  ->  READ '(' . ident_list ')'   (rule 33)

    IDENTIFIER	shift, and go to state 4

    ident_list	go to state 78



state 62

    write_stmt  ->  WRITE '(' . expr_list ')'   (rule 34)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    expr_list	go to state 79
    expr	go to state 80
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 63

    goto_stmt  ->  GOTO IDENTIFIER .   (rule 35)

    $default	reduce using rule 35 (goto_stmt)



state 64

    compound_stmt  ->  BEGIN_STMT stmt_list END .   (rule 11)

    $default	reduce using rule 11 (compound_stmt)



state 65

    stmt_list  ->  stmt_list ';' . stmt   (rule 12)

    IDENTIFIER	shift, and go to state 13
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    stmt	go to state 81
    label	go to state 22
    unlabelled_stmt	go to state 23
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 66

    stmt  ->  label ':' . unlabelled_stmt   (rule 14)

    IDENTIFIER	shift, and go to state 82
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    unlabelled_stmt	go to state 83
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 67

    loop_stmt  ->  stmt_prefix DO . stmt_list stmt_suffix   (rule 28)

    IDENTIFIER	shift, and go to state 13
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    stmt_list	go to state 84
    stmt	go to state 21
    label	go to state 22
    unlabelled_stmt	go to state 23
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 68

    assign_stmt  ->  IDENTIFIER ASSIGN expr .   (rule 24)

    $default	reduce using rule 24 (assign_stmt)



state 69

    factor  ->  NOT factor .   (rule 57)

    $default	reduce using rule 57 (factor)



state 70

    factor  ->  '(' expr . ')'   (rule 55)

    ')' 	shift, and go to state 85



state 71

    factor_a  ->  '-' factor .   (rule 51)

    $default	reduce using rule 51 (factor_a)



state 72

    if_stmt  ->  IF cond THEN . stmt   (rule 26)
    if_stmt  ->  IF cond THEN . stmt ELSE stmt   (rule 27)

    IDENTIFIER	shift, and go to state 13
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    stmt	go to state 86
    label	go to state 22
    unlabelled_stmt	go to state 23
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 73

    simple_expr  ->  simple_expr ADDOP . term   (rule 41)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    term	go to state 87
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 74

    expr  ->  simple_expr RELOP . simple_expr   (rule 39)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    simple_expr	go to state 88
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 75

    simple_expr  ->  simple_expr '-' . term   (rule 42)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    term	go to state 89
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 76

    term  ->  term MULOP . factor_a   (rule 44)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 90
    factor	go to state 58
    constant	go to state 59



state 77

    function_ref_par  ->  variable '(' . expr_list ')'   (rule 47)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    expr_list	go to state 91
    expr	go to state 80
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 78

    ident_list  ->  ident_list . ',' IDENTIFIER   (rule 5)
    read_stmt  ->  READ '(' ident_list . ')'   (rule 33)

    ',' 	shift, and go to state 12
    ')' 	shift, and go to state 92



state 79

    write_stmt  ->  WRITE '(' expr_list . ')'   (rule 34)
    expr_list  ->  expr_list . ',' expr   (rule 37)

    ',' 	shift, and go to state 93
    ')' 	shift, and go to state 94



state 80

    expr_list  ->  expr .   (rule 36)

    $default	reduce using rule 36 (expr_list)



state 81

    stmt_list  ->  stmt_list ';' stmt .   (rule 12)

    $default	reduce using rule 12 (stmt_list)



state 82

    assign_stmt  ->  IDENTIFIER . ASSIGN expr   (rule 24)

    ASSIGN	shift, and go to state 38



state 83

    stmt  ->  label ':' unlabelled_stmt .   (rule 14)

    $default	reduce using rule 14 (stmt)



state 84

    stmt_list  ->  stmt_list . ';' stmt   (rule 12)
    loop_stmt  ->  stmt_prefix DO stmt_list . stmt_suffix   (rule 28)

    END 	shift, and go to state 95
    UNTIL	shift, and go to state 96
    ';' 	shift, and go to state 65

    stmt_suffix	go to state 97



state 85

    factor  ->  '(' expr ')' .   (rule 55)

    $default	reduce using rule 55 (factor)



state 86

    if_stmt  ->  IF cond THEN stmt .   (rule 26)
    if_stmt  ->  IF cond THEN stmt . ELSE stmt   (rule 27)

    ELSE	shift, and go to state 98

    $default	reduce using rule 26 (if_stmt)



state 87

    simple_expr  ->  simple_expr ADDOP term .   (rule 41)
    term  ->  term . MULOP factor_a   (rule 44)

    MULOP	shift, and go to state 76

    $default	reduce using rule 41 (simple_expr)



state 88

    expr  ->  simple_expr RELOP simple_expr .   (rule 39)
    simple_expr  ->  simple_expr . ADDOP term   (rule 41)
    simple_expr  ->  simple_expr . '-' term   (rule 42)

    ADDOP	shift, and go to state 73
    '-' 	shift, and go to state 75

    $default	reduce using rule 39 (expr)



state 89

    simple_expr  ->  simple_expr '-' term .   (rule 42)
    term  ->  term . MULOP factor_a   (rule 44)

    MULOP	shift, and go to state 76

    $default	reduce using rule 42 (simple_expr)



state 90

    term  ->  term MULOP factor_a .   (rule 44)

    $default	reduce using rule 44 (term)



state 91

    expr_list  ->  expr_list . ',' expr   (rule 37)
    function_ref_par  ->  variable '(' expr_list . ')'   (rule 47)

    ',' 	shift, and go to state 93
    ')' 	shift, and go to state 99



state 92

    read_stmt  ->  READ '(' ident_list ')' .   (rule 33)

    $default	reduce using rule 33 (read_stmt)



state 93

    expr_list  ->  expr_list ',' . expr   (rule 37)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    expr	go to state 100
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 94

    write_stmt  ->  WRITE '(' expr_list ')' .   (rule 34)

    $default	reduce using rule 34 (write_stmt)



state 95

    stmt_suffix  ->  END .   (rule 32)

    $default	reduce using rule 32 (stmt_suffix)



state 96

    stmt_suffix  ->  UNTIL . cond   (rule 31)

    NOT 	shift, and go to state 39
    INT_CONSTANT	shift, and go to state 40
    REAL_CONSTANT	shift, and go to state 41
    BOOL_CONSTANT	shift, and go to state 42
    IDENTIFIER	shift, and go to state 43
    IDENTIFIER_F	shift, and go to state 44
    CHAR_CONSTANT	shift, and go to state 45
    EOLN	shift, and go to state 46
    '(' 	shift, and go to state 47
    '-' 	shift, and go to state 48

    cond	go to state 101
    expr	go to state 50
    simple_expr	go to state 51
    term	go to state 52
    function_ref	go to state 53
    function_ref_par	go to state 54
    variable	go to state 55
    simple_variable_or_proc	go to state 56
    factor_a	go to state 57
    factor	go to state 58
    constant	go to state 59



state 97

    loop_stmt  ->  stmt_prefix DO stmt_list stmt_suffix .   (rule 28)

    $default	reduce using rule 28 (loop_stmt)



state 98

    if_stmt  ->  IF cond THEN stmt ELSE . stmt   (rule 27)

    IDENTIFIER	shift, and go to state 13
    BEGIN_STMT	shift, and go to state 8
    IF  	shift, and go to state 14
    WHILE	shift, and go to state 15
    READ	shift, and go to state 16
    WRITE	shift, and go to state 17
    GOTO	shift, and go to state 18

    $default	reduce using rule 30 (stmt_prefix)

    compound_stmt	go to state 19
    stmt	go to state 102
    label	go to state 22
    unlabelled_stmt	go to state 23
    assign_stmt	go to state 24
    if_stmt	go to state 25
    loop_stmt	go to state 26
    stmt_prefix	go to state 27
    read_stmt	go to state 28
    write_stmt	go to state 29
    goto_stmt	go to state 30



state 99

    function_ref_par  ->  variable '(' expr_list ')' .   (rule 47)

    $default	reduce using rule 47 (function_ref_par)



state 100

    expr_list  ->  expr_list ',' expr .   (rule 37)

    $default	reduce using rule 37 (expr_list)



state 101

    stmt_suffix  ->  UNTIL cond .   (rule 31)

    $default	reduce using rule 31 (stmt_suffix)



state 102

    if_stmt  ->  IF cond THEN stmt ELSE stmt .   (rule 27)

    $default	reduce using rule 27 (if_stmt)



state 103

    $   	go to state 104



state 104

    $   	go to state 105



state 105

    $default	accept
